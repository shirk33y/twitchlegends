<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Twitch Realtime Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- App Theme -->
  <style>
    :root{
      --bg:#0f1220;
      --panel:#171a2a;
      --panel-2:#1d2135;
      --text:#e8eaf6;
      --muted:#9aa1b5;
      --accent:#9146FF; /* Twitch purple */
      --danger:#ff4d4f;
      --success:#2ecc71;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% -10%, #22254a55 0%, transparent 60%),
                  radial-gradient(1000px 600px at 100% 0%, #2c2f5a44 0%, transparent 60%),
                  var(--bg);
      color:var(--text);
      font: 15px/1.5 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    /* Preact root mirrors body flex so the internal layout is height-constrained */
    #app{ display:flex; flex-direction:column; gap:16px; min-height:100vh }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:16px 20px;
      min-height:64px; /* keep header height stable */
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .brand .logo{
      width:34px;height:34px;border-radius:10px;background:var(--accent);
      display:grid;place-items:center;color:#fff;box-shadow: var(--shadow);
      font-weight:800;
    }
    .actions{
      display:flex;align-items:center;gap:10px;
    }
    button, .btn{
      appearance:none;border:none;background:var(--accent);color:white;
      padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;
      transition:.2s transform,.2s opacity,.2s background;
      box-shadow: var(--shadow);
      line-height:1;
      display:inline-flex;align-items:center;justify-content:center;
    }
    button.secondary{
      background:transparent;border:1px solid #3a3f6a;color:var(--text);
    }
    button:active{transform: translateY(1px)}
    button:disabled{opacity:.6;cursor:not-allowed}

    .container{
      flex:1;
      padding:0 20px 20px;
      display:grid;
      grid-template-rows: 1fr; /* single row to let the panel fill */
      gap:14px;
      max-width:1100px;
      margin:0 auto;
      width:100%;
      min-height:0; /* allow inner grids to scroll */
      overflow:hidden; /* prevent growth, let inner scroll containers handle overflow */
    }

    .panel{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid #2b3154;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      height:100%;
      display:grid;
      grid-template-rows: 48px 68px minmax(0, 1fr); /* fixed header + controls heights (40px + 14px*2), stable chat */
      min-height:0; /* allow chat to shrink/scroll */
      overflow:hidden; /* keep internal scroll only */
    }

    .controls{
      display:grid;grid-template-columns: 1fr auto auto;gap:10px;
      padding:14px;
      align-items:center;
    }
    .identity{
      display:flex;align-items:center;gap:10px;min-width:0;
    }
    .avatar{
      width:32px;height:32px;border-radius:50%;background:#2e335a;flex:0 0 auto;
      display:grid;place-items:center;font-size:12px;color:#d1d6ff;border:1px solid #3a3f6a
    }
    .userline{
      min-width:0;display:flex;flex-direction:column;
    }
    .userline b{
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .userline small{color:var(--muted);white-space:nowrap}

    .field{
      display:flex;gap:8px;align-items:center;justify-content:flex-start;
      flex-wrap:nowrap;white-space:nowrap;
    }
    .field > *{ flex:0 0 auto }
    input[type="text"]{
      background:#10142a;border:1px solid #2b3154;color:var(--text);
      padding:10px 12px;border-radius:10px;min-width:220px;outline:none;
      transition:border-color .2s;line-height:1;
    }
    input[type="text"]:focus{border-color:#5160ff}

    .chat{
      display:grid;grid-template-rows: minmax(0, 1fr) auto;min-height:0; /* remove growth, enable inner scroll */
      overflow:hidden; /* confine scroll to messages */
      position:relative; /* allow overlay resume button */
    }
    .messages{
      overflow:auto;padding:8px 12px 8px;
      height:100%;
      scroll-behavior:smooth;
      min-height:0; /* critical for flex/grid children to allow scrolling */
      scrollbar-gutter: stable both-edges; /* prevent layout shift when scrollbars appear */
      /* Hide scrollbars cross-browser */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE 10+ */
    }
    .messages::-webkit-scrollbar{ width:0; height:0 } /* WebKit */
    .msg{
      display:flex;
      flex-direction:column;
      gap:0;
      padding:0 2px; /* no vertical padding to keep 24px row height */
      background:transparent;
      border:none;
      border-radius:0;
      transition:none;
    }
    .msg:hover{background:transparent}
    .meta{
      display:flex;gap:8px;align-items:center;justify-content:space-between;color:#c9cdfc;
      font-size:14px;opacity:.95;line-height:24px; /* match VirtualList rowHeight */
    }
    .meta-left{display:flex;align-items:center;gap:8px;min-width:0;flex:1}
    .meta-right{margin-left:12px;flex:0 0 auto}
    .badge{
      display:inline-flex;align-items:center;gap:4px;font-size:11px;
      background:transparent;border:none;color:#e1e3ff;
      text-transform:uppercase;letter-spacing:.3px;padding:0;
    }
    .name{font-weight:700}
    .time{display:none}
    .text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#eef0ff;font-size:16px}

    .composer{
      display:flex;gap:10px;padding:12px;border-top:1px solid #2b3154;background:#121632aa;border-radius:0 0 var(--radius) var(--radius)
    }
    .composer input{ flex:1; min-width:0 }
    /* Unify sizing for inputs and buttons */
    .controls .field input, .controls .field button,
    .composer input, .composer button { height:40px }
    .controls .field input, .composer input { padding:0 12px }
    .controls .field button, .composer button { padding:0 14px }
    /* Resume pill button overlay */
    .resume-pill{
      position:absolute;left:0;right:0;transform:none;margin:0 auto;width:max-content;
      bottom:56px; /* sit above composer (40px) + padding */
      padding:6px 12px;font-size:12px;
      background:#0b0e2ccc;color:var(--text);
      border:1px solid #3a3f6a;border-radius:999px;
      box-shadow: var(--shadow);
      outline:none;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;
      user-select:none;pointer-events:auto;z-index:5;
    }
    .resume-pill:active{ transform:none }
    .controls .field input, .composer input { border-radius:10px }
    .status{
      display:flex;gap:8px;align-items:center;color:#b9c0d6;font-size:13px;padding:8px 14px;border-bottom:1px solid #2b3154;background:#121632aa;border-radius: var(--radius) var(--radius) 0 0;
      min-height:40px; white-space:nowrap; /* stable bar height, avoid wrapping */
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:#666;
      box-shadow:0 0 0 3px #0003 inset;
    }
    .dot.on{background:var(--success)}
    .subtle{color:#9aa1b5}
    .link{color:#cbb4ff;text-decoration:none;border-bottom:1px dashed #5a4fb2}
    .spacer{flex:1}
    .hidden{display:none !important}
    @media (max-width:700px){
      .controls{grid-template-columns: 1fr; align-items:stretch}
      .field{justify-content:stretch}
      /* On small screens, let rows size naturally to avoid overflow */
      .panel{ grid-template-rows: auto auto minmax(0, 1fr) }
    }
  </style>

</head>
<body>
  <div id="app"></div>
  <!-- Import map to ensure all libs resolve to the same preact instance -->
  <script type="importmap">
  {
    "imports": {
      "preact": "https://esm.sh/preact@10.27.2",
      "preact/hooks": "https://esm.sh/preact@10.27.2/hooks",
      "htm": "https://esm.sh/htm@3.1.1"
    }
  }
  </script>
  <script type="module">
    import { h, render } from 'preact';
    import { useState, useEffect, useRef, useCallback, useLayoutEffect } from 'preact/hooks';
    import htm from 'htm';
    import tmi from 'https://esm.sh/tmi.js@1.8.5';
    const html = htm.bind(h);

    // Config
    const TWITCH_CLIENT_ID = 'lihxdhjxpzachp1h2z4nerzxszbgar';
    const REDIRECT_URI = 'https://shirk33y.github.io/twitchlegends/';
    const OAUTH_STATE_KEY = 'tw_state';
    const TOKEN_KEY = 'tw_access_token';
    const USER_KEY = 'tw_user';
    const HISTORY_PREFIX = 'tw_history:';
    const HISTORY_CAP = 1000;

    // OAuth helpers
    const buildAuthUrl = () => {
      const scopes = ['chat:read', 'chat:edit'];
      const state = crypto.getRandomValues(new Uint8Array(16)).reduce((s,b)=>s+('0'+b.toString(16)).slice(-2),'');
      localStorage.setItem(OAUTH_STATE_KEY, state);
      const params = new URLSearchParams({ client_id: TWITCH_CLIENT_ID, redirect_uri: REDIRECT_URI, response_type: 'token', scope: scopes.join(' '), force_verify: 'true', state });
      return `https://id.twitch.tv/oauth2/authorize?${params.toString()}`;
    };
    const parseOAuthHash = () => {
      if (!location.hash.startsWith('#')) return null;
      const p = new URLSearchParams(location.hash.slice(1));
      if (!p.get('access_token')) return null;
      return { access_token: p.get('access_token'), state: p.get('state') };
    };
    const validateToken = async (token) => {
      const r = await fetch('https://id.twitch.tv/oauth2/validate', { headers: { Authorization: 'OAuth ' + token } });
      if (!r.ok) throw new Error('validate failed');
      return r.json(); // { login, user_id, scopes }
    };

    // URL query helpers
    const getChannelFromQuery = () => new URL(location.href).searchParams.get('channel')?.replace(/^#/, '')?.trim() || '';
    const setChannelInQuery = (channel) => { const url = new URL(location.href); channel ? url.searchParams.set('channel', channel) : url.searchParams.delete('channel'); history.replaceState(null, '', url.toString()); };

    // UI bits
    const guessColor = (username) => {
      // deterministic pastel-like color from username
      let hash = 0;
      for (let i = 0; i < (username||'').length; i++) hash = (hash * 31 + username.charCodeAt(i)) | 0;
      const hue = Math.abs(hash) % 360;
      return `hsl(${hue} 70% 70%)`;
    };

    const parseBadges = (tags) => {
      const badges = (tags && tags.badges) || {};
      const list = [];
      if (badges.broadcaster) list.push('Broadcaster');
      if (badges.moderator) list.push('Mod');
      if (badges.vip) list.push('VIP');
      if (badges.subscriber) list.push('Sub');
      if (badges.turbo) list.push('Turbo');
      return list;
    };
    const Dot = ({ on }) => html`<div class=${'dot'+(on?' on':'')}></div>`;

    const MessageRow = (row) => html`
      <div class="msg">
        <div class="meta">
          <div class="meta-left">
            <span class="name" style=${{ color: row.color || '#c9cdfc' }}>${row.username}</span>${': '}<span class="text">${row.text}</span>
          </div>
          <div class="meta-right">${(row.badges||[]).map(b => html`<span class="badge">${b}</span>`)}</div>
        </div>
      </div>
    `;

    const App = () => {
      const [token, setToken] = useState(localStorage.getItem(TOKEN_KEY) || '');
      const [user, setUser] = useState(() => { try { return JSON.parse(localStorage.getItem(USER_KEY)||'null'); } catch { return null; } });
      const [channel, setChannel] = useState(getChannelFromQuery());
      const [channelInput, setChannelInput] = useState(getChannelFromQuery());
      const [connected, setConnected] = useState(false);
      const [connecting, setConnecting] = useState(false);
      const [messages, setMessages] = useState([]);
      const [compose, setCompose] = useState('');
      const clientRef = useRef(null);
      const listRef = useRef(null);
      const [autoScroll, setAutoScroll] = useState(true);
      const scrollIntentRef = useRef(false);
      const intentTimerRef = useRef(null);
      const resumingRef = useRef(false);

      // Legacy DOM is no longer used; Preact renders the full UI.

      // OAuth return
      useEffect(() => {
        const parsed = parseOAuthHash();
        (async () => {
          if (parsed?.access_token) {
            try {
              const expected = localStorage.getItem(OAUTH_STATE_KEY);
              if (expected && expected !== parsed.state) throw new Error('state mismatch');
              const v = await validateToken(parsed.access_token);
              localStorage.setItem(TOKEN_KEY, parsed.access_token);
              localStorage.setItem(USER_KEY, JSON.stringify({ login: v.login, user_id: v.user_id, display_name: v.login }));
              setToken(parsed.access_token);
              setUser({ login: v.login, user_id: v.user_id, display_name: v.login });
            } catch (e) { console.error(e); alert('Login failed'); }
            finally { history.replaceState(null, '', location.pathname + location.search); }
          }
        })();
      }, []);

      // React to query changes (back/forward)
      useEffect(() => {
        const onPop = () => { const c = getChannelFromQuery(); setChannel(c); setChannelInput(c); setMessages([]); };
        window.addEventListener('popstate', onPop);
        return () => window.removeEventListener('popstate', onPop);
      }, []);

      // Load persisted history when channel changes
      useEffect(() => {
        if (!channel) return;
        try {
          const key = HISTORY_PREFIX + channel.toLowerCase();
          const s = localStorage.getItem(key);
          if (s) {
            const arr = JSON.parse(s);
            if (Array.isArray(arr)) {
              setMessages(arr.slice(-HISTORY_CAP));
              setAutoScroll(true);
            }
          } else {
            setMessages([]);
            setAutoScroll(true);
          }
        } catch (_) {
          // ignore storage errors
        }
      }, [channel]);

      // Persist history whenever messages change
      useEffect(() => {
        if (!channel) return;
        try {
          const key = HISTORY_PREFIX + channel.toLowerCase();
          const trimmed = messages.slice(-HISTORY_CAP);
          localStorage.setItem(key, JSON.stringify(trimmed));
        } catch (_) {
          // ignore storage errors
        }
      }, [messages, channel]);

      // Connect when channel or identity changes
      useEffect(() => {
        if (!channel) return;
        let cancelled = false;
        (async () => {
          setConnecting(true);
          if (clientRef.current) { try { await clientRef.current.disconnect(); } catch {} clientRef.current = null; }
          const opts = { connection: { reconnect: true, secure: true }, channels: [channel] };
          if (token && user?.login) opts.identity = { username: user.login, password: 'oauth:' + token };
          const client = new tmi.Client(opts);
          clientRef.current = client;
          client.on('connected', () => { if (!cancelled) { setConnected(true); setConnecting(false); } });
          client.on('disconnected', () => { if (!cancelled) setConnected(false); });
          client.on('message', (ch, tags, msg, self) => {
            if (cancelled) return;
            if (ch.replace('#','').toLowerCase() !== channel.toLowerCase()) return;
            const username = tags['display-name'] || tags.username || 'user';
            const color = tags.color || guessColor(username);
            const badges = parseBadges(tags);
            const row = { username, color, badges, text: msg, ts: Date.now(), self: !!self };
            setMessages(m => {
              const next = m.concat(row);
              return next.length > HISTORY_CAP ? next.slice(-HISTORY_CAP) : next;
            });
          });
          try { await client.connect(); } catch (e) { console.error(e); setConnecting(false); setConnected(false); }
        })();
        return () => { cancelled = true; };
      }, [channel, token, user?.login]);

      // Autoscroll management
      const atBottom = useCallback(() => {
        const el = listRef.current;
        if (!el) return true;
        return (el.scrollHeight - el.clientHeight - el.scrollTop) <= 24;
      }, []);
      // Track user scroll intent to avoid disabling autoscroll due to programmatic scrolls
      useEffect(() => {
        const el = listRef.current; if (!el) return;
        const onUserIntent = () => {
          scrollIntentRef.current = true;
          if (intentTimerRef.current) clearTimeout(intentTimerRef.current);
          intentTimerRef.current = setTimeout(() => { scrollIntentRef.current = false; }, 700);
        };
        const onScroll = () => {
          if (resumingRef.current) return; // ignore scrolls during resume
          if (!scrollIntentRef.current) return; // ignore programmatic scrolls
          setAutoScroll(atBottom());
        };
        el.addEventListener('wheel', onUserIntent, { passive: true });
        el.addEventListener('touchstart', onUserIntent, { passive: true });
        el.addEventListener('mousedown', onUserIntent);
        el.addEventListener('scroll', onScroll, { passive: true });
        return () => {
          el.removeEventListener('wheel', onUserIntent);
          el.removeEventListener('touchstart', onUserIntent);
          el.removeEventListener('mousedown', onUserIntent);
          el.removeEventListener('scroll', onScroll);
        };
      }, [atBottom]);
      useLayoutEffect(() => {
        if (!autoScroll) return;
        const el = listRef.current;
        if (el) el.scrollTop = el.scrollHeight;
      }, [messages.length, autoScroll]);

      // Actions
      const onLogin = () => {
        if (!TWITCH_CLIENT_ID || !REDIRECT_URI) {
          alert('Missing Twitch config');
          return;
        }
        location.href = buildAuthUrl();
      };

      const onLogout = async () => {
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(USER_KEY);
        setToken('');
        setUser(null);
        try {
          await clientRef.current?.disconnect();
        } catch (_) {}
        setConnected(false);
      };

      const onJoin = () => {
        const c = (channelInput || '').trim().replace(/^#/, '');
        if (!c) return;
        setChannel(c);
        setChannelInQuery(c);
        setMessages([]);
      };
      const canSend = !!token && !!user?.login && connected && !!channel;
      const onSend = async (text) => {
        const t = (text||'').trim(); if (!t) return; if (!canSend) return alert('Login and connect first');
        try { await clientRef.current?.say('#'+channel, t); } catch (e) { console.error(e); }
      };
      const onClear = () => {
        setMessages([]);
        if (!channel) return;
        try { localStorage.removeItem(HISTORY_PREFIX + channel.toLowerCase()); } catch (_) {}
      };
      const onResume = (e) => {
        if (e && e.preventDefault) e.preventDefault();
        if (e && e.stopPropagation) e.stopPropagation();
        // Immediately re-enable autoscroll and hide the pill
        setAutoScroll(true);
        // Stop treating subsequent scroll as user-initiated for a short window
        scrollIntentRef.current = false;
        if (intentTimerRef.current) { clearTimeout(intentTimerRef.current); intentTimerRef.current = null; }
        resumingRef.current = true;
        const el = listRef.current;
        // Double rAF to ensure layout is committed before scrolling
        requestAnimationFrame(() => {
          if (el) el.scrollTop = el.scrollHeight;
          requestAnimationFrame(() => {
            if (el) el.scrollTop = el.scrollHeight;
            setTimeout(() => { resumingRef.current = false; }, 200);
          });
        });
      };

      return html`
        <${HeaderComp} loggedIn=${!!user} onLogin=${onLogin} onLogout=${onLogout} user=${user} connection=${connected} />
        <main class="container">
          <section class="panel">
            <div class="status">
              <${Dot} on=${connected} />
              <div>${connecting ? 'Connecting…' : (connected ? `Connected to #${channel||''}` : 'Disconnected')}</div>
              <div class="spacer"></div>
              <div class="subtle">${user ? `@${user.login}` : 'Not logged in'}</div>
            </div>
            <div class="controls">
              <div class="identity">
                <div class="avatar">${(user?.display_name||user?.login||'?').slice(0,1).toUpperCase()}</div>
                <div class="userline">
                  <b id="displayName">${user?.display_name||'Guest'}</b>
                  <small id="loginName">${user?('@'+user.login):'@anonymous'}</small>
                </div>
              </div>
              <div class="field">
                <label class="subtle" for="channel">Channel</label>
                <input id="channel" value=${channelInput} onInput=${e=>setChannelInput(e.currentTarget.value)} placeholder="e.g. twitch" />
                <button onClick=${onJoin}>Join</button>
              </div>
              <div class="field">
                <button class="secondary" onClick=${onClear}>Clear</button>
              </div>
            </div>
            <div class="chat">
              <div ref=${listRef} class="messages">
                ${messages.map((row, idx) => html`<${MessageRow} key=${idx} ...${row} />`)}
              </div>
              ${!autoScroll && html`<button class="resume-pill" onClick=${onResume}>Resume</button>`}
              <div class="composer">
                <input
                  value=${compose}
                  onInput=${e=>setCompose(e.currentTarget.value)}
                  onKeyDown=${e=>{ if (e.key==='Enter' && !e.shiftKey) { e.preventDefault(); onSend(compose); setCompose(''); } }}
                  placeholder=${canSend? 'Type a message...' : 'Login with Twitch and join a channel to chat'}
                  disabled=${!canSend}
                />
                <button onClick=${()=>{ onSend(compose); setCompose(''); }} disabled=${!canSend}>Send</button>
              </div>
            </div>
          </section>
        </main>
      `;
    };

    const HeaderComp = ({ loggedIn, onLogin, onLogout, user }) => html`
      <header>
        <div class="brand">
          <div class="logo">TW</div>
          <div>
            <div style="font-size:15px">Twitch Chat Viewer</div>
            <div style="font-size:12px; color:var(--muted)">${loggedIn ? `Logged in as @${user?.login}` : 'Login and watch chat in real time'}</div>
          </div>
        </div>
        <div class="actions">
          ${!loggedIn ? html`<button onClick=${onLogin}>Login with Twitch</button>` : html`<button class="secondary" onClick=${onLogout}>Logout</button>`}
        </div>
      </header>
    `;

    render(html`<${App}/>`, document.getElementById('app'));
  </script>
</body>
</html>