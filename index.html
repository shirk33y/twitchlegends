<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Twitch Realtime Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- App Theme -->
  <style>
    :root{
      --bg:#0f1220;
      --panel:#171a2a;
      --panel-2:#1d2135;
      --text:#e8eaf6;
      --muted:#9aa1b5;
      --accent:#9146FF; /* Twitch purple */
      --danger:#ff4d4f;
      --success:#2ecc71;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% -10%, #22254a55 0%, transparent 60%),
                  radial-gradient(1000px 600px at 100% 0%, #2c2f5a44 0%, transparent 60%),
                  var(--bg);
      color:var(--text);
      font: 15px/1.5 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:16px 20px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .brand .logo{
      width:34px;height:34px;border-radius:10px;background:var(--accent);
      display:grid;place-items:center;color:#fff;box-shadow: var(--shadow);
      font-weight:800;
    }
    .actions{
      display:flex;align-items:center;gap:10px;
    }
    button, .btn{
      appearance:none;border:none;background:var(--accent);color:white;
      padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;
      transition:.2s transform,.2s opacity,.2s background;
      box-shadow: var(--shadow);
    }
    button.secondary{
      background:transparent;border:1px solid #3a3f6a;color:var(--text);
    }
    button:active{transform: translateY(1px)}
    button:disabled{opacity:.6;cursor:not-allowed}

    .container{
      flex:1;
      padding:0 20px 20px;
      display:grid;
      grid-template-rows: 1fr; /* single row to let the panel fill */
      gap:14px;
      max-width:1100px;
      margin:0 auto;
      width:100%;
      min-height:0; /* allow inner grids to scroll */
      overflow:hidden; /* prevent growth, let inner scroll containers handle overflow */
    }

    .panel{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid #2b3154;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      height:100%;
      display:grid;
      grid-template-rows: auto auto minmax(0, 1fr); /* status, controls, chat */
      min-height:0; /* allow chat to shrink/scroll */
      overflow:hidden; /* keep internal scroll only */
    }

    .controls{
      display:grid;grid-template-columns: 1fr auto auto;gap:10px;
      padding:14px;
      align-items:center;
    }
    .identity{
      display:flex;align-items:center;gap:10px;min-width:0;
    }
    .avatar{
      width:32px;height:32px;border-radius:50%;background:#2e335a;flex:0 0 auto;
      display:grid;place-items:center;font-size:12px;color:#d1d6ff;border:1px solid #3a3f6a
    }
    .userline{
      min-width:0;display:flex;flex-direction:column;
    }
    .userline b{
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .userline small{color:var(--muted)}

    .field{
      display:flex;gap:8px;align-items:center;justify-content:flex-end;
    }
    input[type="text"]{
      background:#10142a;border:1px solid #2b3154;color:var(--text);
      padding:10px 12px;border-radius:10px;min-width:220px;outline:none;
      transition:border-color .2s;
    }
    input[type="text"]:focus{border-color:#5160ff}

    .chat{
      display:grid;grid-template-rows: minmax(0, 1fr) auto;min-height:0; /* remove growth, enable inner scroll */
      overflow:hidden; /* confine scroll to messages */
      position:relative; /* allow overlay resume button */
    }
    .messages{
      overflow:auto;padding:8px 12px 8px;
      display:block; /* let VirtualList control internals */
      scroll-behavior:smooth;
      min-height:0; /* critical for flex/grid children to allow scrolling */
      max-height:100%;
      scrollbar-gutter: stable both-edges; /* prevent layout shift when scrollbars appear */
      /* Hide scrollbars cross-browser */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE 10+ */
    }
    .messages::-webkit-scrollbar{ width:0; height:0 } /* WebKit */
    .msg{
      display:flex;
      flex-direction:column;
      gap:0;
      padding:0 2px; /* no vertical padding to keep 24px row height */
      background:transparent;
      border:none;
      border-radius:0;
      transition:none;
    }
    .msg:hover{background:transparent}
    .meta{
      display:flex;gap:8px;align-items:center;justify-content:space-between;color:#c9cdfc;
      font-size:14px;opacity:.95;line-height:24px; /* match VirtualList rowHeight */
    }
    .meta-left{display:flex;align-items:center;gap:8px;min-width:0;flex:1}
    .meta-right{margin-left:12px;flex:0 0 auto}
    .badge{
      display:inline-flex;align-items:center;gap:4px;font-size:11px;
      background:#2a2f5a;border:1px solid #3a3f6a;color:#e1e3ff;
      border-radius:999px;padding:0 5px; /* smaller label padding */
    }
    .name{font-weight:700}
    .time{display:none}
    .text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#eef0ff;font-size:16px}

    .composer{
      display:flex;gap:10px;padding:12px;border-top:1px solid #2b3154;background:#121632aa;border-radius:0 0 var(--radius) var(--radius)
    }
    .resume-pill{
      position:absolute;left:50%;right:auto;transform:translateX(-50%);margin:0;width:auto; /* precise center */
      bottom:58px; /* above composer */
      padding:6px 12px;
      font-size:12px;
      background:#0b0e2ccc;
      color:var(--text);
      border:1px solid #3a3f6a;
      border-radius:999px;
      box-shadow: var(--shadow);
      opacity:.9;
      transition: opacity .2s ease;
      z-index: 5;
      outline:none; display:inline-flex; align-items:center; justify-content:center; pointer-events:auto; user-select:none;
    }
    .resume-pill:hover{ opacity:1 }
    .info{
      margin-top:-2px;color:var(--muted);font-size:12px;text-align:right;padding:0 2px 6px;
    }
    .status{
      display:flex;gap:8px;align-items:center;color:#b9c0d6;font-size:13px;padding:8px 14px;border-bottom:1px solid #2b3154;background:#121632aa;border-radius: var(--radius) var(--radius) 0 0;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:#666;
      box-shadow:0 0 0 3px #0003 inset;
    }
    .dot.on{background:var(--success)}
    .subtle{color:#9aa1b5}
    .link{color:#cbb4ff;text-decoration:none;border-bottom:1px dashed #5a4fb2}
    .spacer{flex:1}
    .hidden{display:none !important}
    @media (max-width:700px){
      .controls{grid-template-columns: 1fr; align-items:stretch}
      .field{justify-content:stretch}
    }
  </style>

</head>
<body>
  <header>
    <div class="brand">
      <div class="logo">TW</div>
      <div>
        <div style="font-size:15px">Twitch Chat Viewer</div>
        <div style="font-size:12px; color:var(--muted)">Login and watch chat in real time</div>
      </div>
    </div>
    <div class="actions">
      <button id="loginBtn">Login with Twitch</button>
      <button id="logoutBtn" class="secondary hidden">Logout</button>
    </div>
  </header>

  <main class="container">
    <section class="panel">
      <div class="status">
        <div id="connDot" class="dot"></div>
        <div id="connText">Disconnected</div>
        <div class="spacer"></div>
        <div id="selfInfo" class="subtle">Not logged in</div>
      </div>
      <div class="controls">
        <div class="identity">
          <div id="avatar" class="avatar">?</div>
          <div class="userline">
            <b id="displayName">Guest</b>
            <small id="loginName">@anonymous</small>
          </div>
        </div>
        <div class="field">
          <label for="channel" class="subtle">Channel</label>
          <input id="channel" type="text" placeholder="e.g. twitch" />
          <button id="joinBtn">Join</button>
        </div>
        <div class="field">
          <button id="clearBtn" class="secondary">Clear</button>
        </div>
      </div>
      <div class="chat">
        <div id="messages" class="messages"></div>
        <button id="resumeBtn" class="resume-pill hidden">Resume</button>
        <div id="composer" class="composer">
          <input id="inputMsg" type="text" placeholder="Type a message..." />
          <button id="sendBtn">Send</button>
        </div>
      </div>
    </section>
  </main>
  <div id="app"></div>
  <script type="module/disabled">
    import tmi from 'https://esm.sh/tmi.js@1.8.5';
    // Expose globally if any external code expects window.tmi
    window.tmi = tmi;
    // ========= Configuration (set these) =========
    const TWITCH_CLIENT_ID = 'lihxdhjxpzachp1h2z4nerzxszbgar';
    const REDIRECT_URI = 'https://shirk33y.github.io/twitchlegends/'; // must match your Twitch app config

    // ========= OAuth helpers =========
    const OAUTH_STATE_KEY = 'tw_state';
    const TOKEN_KEY = 'tw_access_token';
    const USER_KEY = 'tw_user';
    const CHANNEL_KEY = 'tw_channel';

    function buildAuthUrl() {
      const scopes = [
        // Scopes needed: read chat and send messages
        'chat:read',
        'chat:edit'
      ];
      const state = crypto.getRandomValues(new Uint8Array(16)).reduce((s,b)=>s+('0'+b.toString(16)).slice(-2),'');
      localStorage.setItem(OAUTH_STATE_KEY, state);

      const params = new URLSearchParams({
        client_id: TWITCH_CLIENT_ID,
        redirect_uri: REDIRECT_URI,
        response_type: 'token',
        scope: scopes.join(' '),
        force_verify: 'true',
        state
      });
      return `https://id.twitch.tv/oauth2/authorize?${params.toString()}`;
    }

    function parseHashFragment() {
      if (!location.hash.startsWith('#')) return null;
      const params = new URLSearchParams(location.hash.slice(1));
      if (!params.has('access_token')) return null;
      return {
        access_token: params.get('access_token'),
        scope: (params.get('scope') || '').split(' ').filter(Boolean),
        state: params.get('state'),
        token_type: params.get('token_type')
      };
    }

    async function validateToken(token) {
      const res = await fetch('https://id.twitch.tv/oauth2/validate', {
        headers: { 'Authorization': 'OAuth ' + token }
      });
      if (!res.ok) throw new Error('Token validate failed');
      return res.json(); // {client_id, login, user_id, expires_in, scopes}
    }

    function saveToken(token, user) {
      localStorage.setItem(TOKEN_KEY, token);
      if (user) localStorage.setItem(USER_KEY, JSON.stringify(user));
    }
    function getSavedToken() {
      return localStorage.getItem(TOKEN_KEY);
    }
    function getSavedUser() {
      const s = localStorage.getItem(USER_KEY);
      try { return s ? JSON.parse(s) : null } catch { return null }
    }
    function clearAuth() {
      localStorage.removeItem(TOKEN_KEY);
      localStorage.removeItem(USER_KEY);
      localStorage.removeItem(OAUTH_STATE_KEY);
    }

    // ========= UI refs =========
    const $ = sel => document.querySelector(sel);
    const loginBtn = $('#loginBtn');
    const logoutBtn = $('#logoutBtn');
    const displayNameEl = $('#displayName');
    const loginNameEl = $('#loginName');
    const avatarEl = $('#avatar');
    const messagesEl = $('#messages');
    const channelInput = $('#channel');
    const joinBtn = $('#joinBtn');
    const clearBtn = $('#clearBtn');
    const connDot = $('#connDot');
    const connText = $('#connText');
    const selfInfo = $('#selfInfo');
    const composer = $('#composer');
    const inputMsg = $('#inputMsg');
    const sendBtn = $('#sendBtn');
    const resumeBtn = $('#resumeBtn');

    // ========= Chat (tmi.js) =========
    let client = null;
    let currentChannel = null;
    let currentColorMap = new Map(); // user => color
    let isConnected = false;
    let autoScroll = true;
    const SCROLL_BOTTOM_THRESHOLD = 24;

    function setConnectionStatus(connected, text) {
      isConnected = connected;
      connDot.classList.toggle('on', connected);
      connText.textContent = text || (connected ? 'Connected' : 'Disconnected');
      updateComposerState();
      updateResumeUI();
    }

    function setLoggedIn(user) {
      if (user) {
        loginBtn.classList.add('hidden');
        logoutBtn.classList.remove('hidden');
        displayNameEl.textContent = user.display_name || user.login || 'User';
        loginNameEl.textContent = '@' + (user.login || 'user');
        avatarEl.textContent = (user.display_name || user.login || 'U').slice(0,1).toUpperCase();
        selfInfo.textContent = `Logged in as ${user.login}`;
      } else {
        loginBtn.classList.remove('hidden');
        logoutBtn.classList.add('hidden');
        displayNameEl.textContent = 'Guest';
        loginNameEl.textContent = '@anonymous';
        avatarEl.textContent = '?';
        selfInfo.textContent = 'Not logged in';
      }
    }

    function renderMessage({timestamp, username, color, badges, text}) {
      const wrap = document.createElement('div');
      wrap.className = 'msg';

      const meta = document.createElement('div');
      meta.className = 'meta';
      const metaLeft = document.createElement('div');
      metaLeft.className = 'meta-left';
      const metaRight = document.createElement('div');
      metaRight.className = 'meta-right';

      const name = document.createElement('span');
      name.className = 'name';
      name.style.color = color || '#c9cdfc';
      name.textContent = username;
      metaLeft.appendChild(name);

      // Separator and one-line message text
      metaLeft.appendChild(document.createTextNode(': '));
      const textSpan = document.createElement('span');
      textSpan.className = 'text';
      textSpan.textContent = text;
      metaLeft.appendChild(textSpan);

      // Badges on the right
      if (badges && badges.length) {
        for (const b of badges) {
          const el = document.createElement('span');
          el.className = 'badge';
          el.textContent = b;
          metaRight.appendChild(el);
        }
      }

      meta.appendChild(metaLeft);
      meta.appendChild(metaRight);

      wrap.appendChild(meta);
      messagesEl.appendChild(wrap);

      // Auto-scroll only if user is near bottom
      if (autoScroll) {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      } else {
        updateResumeUI();
      }
    }

    function guessColor(username) {
      if (currentColorMap.has(username)) return currentColorMap.get(username);
      // deterministic pastel-ish
      let hash = 0;
      for (let i=0;i<username.length;i++) hash = (hash*31 + username.charCodeAt(i)) | 0;
      const hue = Math.abs(hash) % 360;
      const c = `hsl(${hue} 70% 70%)`;
      currentColorMap.set(username, c);
      return c;
    }

    function resetChat() {
      messagesEl.innerHTML = '';
      currentColorMap.clear();
      autoScroll = true;
      updateResumeUI();
    }

    function atBottom() {
      const el = messagesEl;
      return (el.scrollHeight - el.clientHeight - el.scrollTop) <= SCROLL_BOTTOM_THRESHOLD;
    }

    function parseBadges(tags) {
      const badges = tags.badges || {};
      const list = [];
      if (badges.broadcaster) list.push('Broadcaster');
      if (badges.moderator) list.push('Mod');
      if (badges.vip) list.push('VIP');
      if (badges.subscriber) list.push('Sub');
      if (badges.turbo) list.push('Turbo');
      return list;
    }

    function canSend() {
      const token = getSavedToken();
      const user = getSavedUser();
      // Require identity token and login to attempt sending
      if (!token || !(user && user.login)) return false;
      return isConnected && !!currentChannel;
    }

    function updateComposerState() {
      if (!composer || !inputMsg || !sendBtn) return;
      const enabled = canSend();
      inputMsg.disabled = !enabled;
      sendBtn.disabled = !enabled;
      if (!enabled) {
        inputMsg.placeholder = 'Login with Twitch and join a channel to chat';
      } else {
        inputMsg.placeholder = 'Type a message...';
      }
    }

    function updateResumeUI() {
      if (!resumeBtn) return;
      resumeBtn.classList.toggle('hidden', autoScroll);
    }

    async function sendMessage() {
      const text = (inputMsg?.value || '').trim();
      if (!text) return;
      if (!canSend()) {
        alert('You must be logged in and connected to send messages.');
        return;
      }
      try {
        const channelName = (currentChannel || '').replace(/^#/, '');
        await client.say('#' + channelName, text);
        const user = getSavedUser();
        renderMessage({
          timestamp: Date.now(),
          username: user?.display_name || user?.login || 'Me',
          color: '#cbb4ff',
          badges: ['You'],
          text
        });
        inputMsg.value = '';
      } catch (e) {
        renderMessage({
          timestamp: Date.now(),
          username: 'System',
          color: '#ff9aa5',
          badges: ['Error'],
          text: 'Failed to send: ' + (e?.message || e)
        });
      }
    }

    async function connectChat(channel, token, login) {
      if (client) {
        try { await client.disconnect(); } catch {}
        client = null;
      }
      setConnectionStatus(false, 'Connecting...');
      // identity can be omitted to connect anonymously; when provided, use oauth token and login
      const opts = {
        connection: { reconnect: true, secure: true },
        channels: [channel]
      };
      if (token && login) {
        opts.identity = { username: login, password: 'oauth:' + token };
      }
      client = new tmi.Client(opts);

      client.on('message', (ch, tags, message, self) => {
        // only channel being watched
        if (ch.replace('#','').toLowerCase() !== channel.toLowerCase()) return;
        const username = tags['display-name'] || tags.username || 'user';
        const color = tags.color || guessColor(username);
        renderMessage({
          timestamp: Date.now(),
          username,
          color,
          badges: parseBadges(tags),
          text: message
        });
      });

      client.on('connected', () => {
        setConnectionStatus(true, `Connected to #${channel}`);
      });

      client.on('disconnected', () => {
        setConnectionStatus(false, `Disconnected from #${channel}`);
      });

      try {
        await client.connect();
        currentChannel = channel;
        updateComposerState();
        updateHash(channel);
      } catch (e) {
        setConnectionStatus(false, 'Failed to connect');
        renderMessage({
          timestamp: Date.now(),
          username: 'System',
          color: '#ff9aa5',
          badges: ['Error'],
          text: 'Failed to connect: ' + (e?.message || e)
        });
      }
    }

    // ========= Event Wiring =========
    loginBtn.addEventListener('click', () => {
      if (!TWITCH_CLIENT_ID || TWITCH_CLIENT_ID === 'YOUR_TWITCH_CLIENT_ID') {
        alert('Please set TWITCH_CLIENT_ID in the code.');
        return;
      }
      if (!REDIRECT_URI || REDIRECT_URI === 'YOUR_REDIRECT_URI') {
        alert('Please set REDIRECT_URI in the code (must match Twitch app).');
        return;
      }
      location.href = buildAuthUrl();
    });

    logoutBtn.addEventListener('click', async () => {
      clearAuth();
      setLoggedIn(null);
      resetChat();
      if (client) { try { await client.disconnect(); } catch {} client = null; }
      setConnectionStatus(false, 'Disconnected');
    });

    joinBtn.addEventListener('click', async () => {
      const channel = (channelInput.value || '').trim().replace(/^#/, '');
      if (!channel) {
        alert('Enter a channel name.');
        return;
      }
      resetChat();
      const token = getSavedToken();
      const user = getSavedUser();
      updateHash(channel);
      await connectChat(channel, token, user?.login);
    });

    clearBtn.addEventListener('click', resetChat);

    channelInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') joinBtn.click();
    });

    sendBtn.addEventListener('click', sendMessage);
    inputMsg.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
    });

    // Track user intent to scroll (to avoid accidental pauses from programmatic scrolls)
    let userScrollIntent = false;
    let userIntentTimer = null;
    function markUserIntent() {
      userScrollIntent = true;
      if (userIntentTimer) clearTimeout(userIntentTimer);
      userIntentTimer = setTimeout(() => { userScrollIntent = false; }, 800);
    }
    messagesEl.addEventListener('wheel', markUserIntent, { passive: true });
    messagesEl.addEventListener('touchstart', markUserIntent, { passive: true });
    messagesEl.addEventListener('mousedown', markUserIntent);

    messagesEl.addEventListener('scroll', () => {
      // Pause autoscroll only when the user is actively scrolling up
      if (userScrollIntent && autoScroll && !atBottom()) {
        autoScroll = false;
        updateResumeUI();
      } else if (!autoScroll) {
        // Stay paused until user clicks Resume; keep hint visible
        updateResumeUI();
      }
    });

    resumeBtn.addEventListener('click', () => {
      // Reset any prior intent and resume immediately
      autoScroll = true;
      if (typeof userIntentTimer !== 'undefined' && userIntentTimer) clearTimeout(userIntentTimer);
      if (typeof userScrollIntent !== 'undefined') userScrollIntent = false;
      messagesEl.scrollTop = messagesEl.scrollHeight;
      updateResumeUI();
    });

    // ========= Init: handle OAuth return, restore session =========
    function getChannelFromUrl() {
      const raw = (location.hash || '').replace(/^#/, '').trim();
      // If hash looks like OAuth fragment (contains '=') treat as not a channel
      if (raw && !raw.includes('=')) return decodeURIComponent(raw);
      const url = new URL(location.href);
      const q = (url.searchParams.get('channel') || '').trim();
      if (q) {
        const cleaned = q.replace(/^#/, '');
        history.replaceState(null, '', '#' + encodeURIComponent(cleaned));
        try { localStorage.setItem(CHANNEL_KEY, cleaned); } catch {}
        return cleaned;
      }
      try {
        const stored = localStorage.getItem(CHANNEL_KEY) || '';
        return stored;
      } catch { return '' }
    }

    function updateHash(channel) {
      if (channel) {
        history.replaceState(null, '', '#' + encodeURIComponent(channel));
        try { localStorage.setItem(CHANNEL_KEY, channel); } catch {}
      }
    }

    async function reconnectWithIdentityIfNeeded() {
      const token = getSavedToken();
      const user = getSavedUser();
      if (currentChannel && token && user?.login) {
        await connectChat(currentChannel, token, user.login);
      }
    }

    window.addEventListener('hashchange', async () => {
      const chan = getChannelFromUrl();
      if (chan && chan.toLowerCase() !== (currentChannel || '').replace(/^#/, '').toLowerCase()) {
        resetChat();
        const token = getSavedToken();
        const user = getSavedUser();
        await connectChat(chan, token, user?.login);
      }
    });

    (async function init() {
      // Handle OAuth redirect hash
      const parsed = parseHashFragment();
      if (parsed?.access_token) {
        try {
          const expected = localStorage.getItem(OAUTH_STATE_KEY);
          if (expected && expected !== parsed.state) throw new Error('State mismatch');
          const v = await validateToken(parsed.access_token);
          // v.login, v.user_id, v.scopes
          saveToken(parsed.access_token, { login: v.login, user_id: v.user_id, display_name: v.login, scopes: v.scopes || [] });
          // Clean OAuth fragment from hash but preserve channel if we have one stored
          let channelToKeep = '';
          try { channelToKeep = localStorage.getItem(CHANNEL_KEY) || ''; } catch {}
          const newHash = channelToKeep ? ('#' + encodeURIComponent(channelToKeep)) : '';
          history.replaceState(null, '', location.pathname + location.search + newHash);
          // If already in a channel, reconnect with identity
          await reconnectWithIdentityIfNeeded();
        } catch (e) {
          console.error(e);
          alert('Login failed: ' + (e?.message || e));
          clearAuth();
        }
      }

      // Restore session
      const token = getSavedToken();
      const user = getSavedUser();
      setLoggedIn(user);
      updateComposerState();
      updateResumeUI();

      // If channel provided via hash or query, auto-join
      const targetChannel = getChannelFromUrl();
      if (targetChannel) {
        channelInput.value = targetChannel;
        await connectChat(targetChannel, token, user?.login);
      }
    })();
  </script>
  <!-- Load tmi.js UMD to avoid ESM/CORS issues; exposes window.tmi -->
  <script src="https://unpkg.com/tmi.js@1.8.5/dist/tmi.min.js"></script>
  <script type="module">
    import { h, render } from 'https://unpkg.com/preact@10.19.6?module';
    import { useState, useEffect, useRef, useCallback } from 'https://unpkg.com/preact@10.19.6/hooks/dist/hooks.module.js';
    import htm from 'https://unpkg.com/htm@3.1.1?module';
    import VirtualList from 'https://unpkg.com/preact-virtual-list@3.0.1?module';
    const html = htm.bind(h);
    const tmi = window.tmi;

    // Config
    const TWITCH_CLIENT_ID = 'lihxdhjxpzachp1h2z4nerzxszbgar';
    const REDIRECT_URI = 'https://shirk33y.github.io/twitchlegends/';
    const OAUTH_STATE_KEY = 'tw_state';
    const TOKEN_KEY = 'tw_access_token';
    const USER_KEY = 'tw_user';

    // OAuth helpers
    const buildAuthUrl = () => {
      const scopes = ['chat:read', 'chat:edit'];
      const state = crypto.getRandomValues(new Uint8Array(16)).reduce((s,b)=>s+('0'+b.toString(16)).slice(-2),'');
      localStorage.setItem(OAUTH_STATE_KEY, state);
      const params = new URLSearchParams({ client_id: TWITCH_CLIENT_ID, redirect_uri: REDIRECT_URI, response_type: 'token', scope: scopes.join(' '), force_verify: 'true', state });
      return `https://id.twitch.tv/oauth2/authorize?${params.toString()}`;
    };
    const parseOAuthHash = () => {
      if (!location.hash.startsWith('#')) return null;
      const p = new URLSearchParams(location.hash.slice(1));
      if (!p.get('access_token')) return null;
      return { access_token: p.get('access_token'), state: p.get('state') };
    };
    const validateToken = async (token) => {
      const r = await fetch('https://id.twitch.tv/oauth2/validate', { headers: { Authorization: 'OAuth ' + token } });
      if (!r.ok) throw new Error('validate failed');
      return r.json(); // { login, user_id, scopes }
    };

    // URL query helpers
    const getChannelFromQuery = () => new URL(location.href).searchParams.get('channel')?.replace(/^#/, '')?.trim() || '';
    const setChannelInQuery = (channel) => { const url = new URL(location.href); channel ? url.searchParams.set('channel', channel) : url.searchParams.delete('channel'); history.replaceState(null, '', url.toString()); };

    // UI bits
    const Dot = ({ on }) => html`<div class=${'dot'+(on?' on':'')}></div>`;

    const MessageRow = (row) => html`
      <div class="msg">
        <div class="meta">
          <div class="meta-left">
            <span class="name" style=${{ color: row.color || '#c9cdfc' }}>${row.username}</span>${': '}<span class="text">${row.text}</span>
          </div>
          <div class="meta-right">${(row.badges||[]).map(b => html`<span class="badge">${b}</span>`)}</div>
        </div>
      </div>
    `;

    const App = () => {
      const [token, setToken] = useState(localStorage.getItem(TOKEN_KEY) || '');
      const [user, setUser] = useState(() => { try { return JSON.parse(localStorage.getItem(USER_KEY)||'null'); } catch { return null; } });
      const [channel, setChannel] = useState(getChannelFromQuery());
      const [channelInput, setChannelInput] = useState(getChannelFromQuery());
      const [connected, setConnected] = useState(false);
      const [connecting, setConnecting] = useState(false);
      const [messages, setMessages] = useState([]);
      const [compose, setCompose] = useState('');
      const clientRef = useRef(null);
      const listRef = useRef(null);
      const [autoScroll, setAutoScroll] = useState(true);

      // Hide legacy static DOM if present
      useEffect(() => { document.querySelectorAll('body>header, body>main').forEach(el => el.style.display='none'); }, []);

      // OAuth return
      useEffect(() => {
        const parsed = parseOAuthHash();
        (async () => {
          if (parsed?.access_token) {
            try {
              const expected = localStorage.getItem(OAUTH_STATE_KEY);
              if (expected && expected !== parsed.state) throw new Error('state mismatch');
              const v = await validateToken(parsed.access_token);
              localStorage.setItem(TOKEN_KEY, parsed.access_token);
              localStorage.setItem(USER_KEY, JSON.stringify({ login: v.login, user_id: v.user_id, display_name: v.login }));
              setToken(parsed.access_token);
              setUser({ login: v.login, user_id: v.user_id, display_name: v.login });
            } catch (e) { console.error(e); alert('Login failed'); }
            finally { history.replaceState(null, '', location.pathname + location.search); }
          }
        })();
      }, []);

      // React to query changes (back/forward)
      useEffect(() => {
        const onPop = () => { const c = getChannelFromQuery(); setChannel(c); setChannelInput(c); setMessages([]); };
        window.addEventListener('popstate', onPop);
        return () => window.removeEventListener('popstate', onPop);
      }, []);

      // Connect when channel or identity changes
      useEffect(() => {
        if (!channel) return;
        let cancelled = false;
        (async () => {
          setConnecting(true);
          if (clientRef.current) { try { await clientRef.current.disconnect(); } catch {} clientRef.current = null; }
          const opts = { connection: { reconnect: true, secure: true }, channels: [channel] };
          if (token && user?.login) opts.identity = { username: user.login, password: 'oauth:' + token };
          const client = new tmi.Client(opts);
          clientRef.current = client;
          client.on('connected', () => { if (!cancelled) { setConnected(true); setConnecting(false); } });
          client.on('disconnected', () => { if (!cancelled) setConnected(false); });
          client.on('message', (ch, tags, msg) => {
            if (cancelled) return;
            if (ch.replace('#','').toLowerCase() !== channel.toLowerCase()) return;
            const username = tags['display-name'] || tags.username || 'user';
            const color = tags.color || guessColor(username);
            const badges = parseBadges(tags);
            setMessages(m => [...m, { username, color, badges, text: msg }]);
          });
          try { await client.connect(); } catch (e) { console.error(e); setConnecting(false); setConnected(false); }
        })();
        return () => { cancelled = true; };
      }, [channel, token, user?.login]);

      // Autoscroll management
      const atBottom = useCallback(() => {
        const el = listRef.current && (listRef.current.base || listRef.current);
        if (!el) return true;
        return (el.scrollHeight - el.clientHeight - el.scrollTop) <= 24;
      }, []);
      useEffect(() => {
        const el = listRef.current && (listRef.current.base || listRef.current); if (!el) return;
        const onScroll = () => setAutoScroll(atBottom());
        el.addEventListener('scroll', onScroll, { passive: true });
        return () => el.removeEventListener('scroll', onScroll);
      }, [atBottom]);
      useEffect(() => {
        if (autoScroll) { const el = listRef.current && (listRef.current.base || listRef.current); if (el) el.scrollTop = el.scrollHeight; }
      }, [messages.length, autoScroll]);

      // Actions
      const onLogin = () => { if (!TWITCH_CLIENT_ID || !REDIRECT_URI) return alert('Missing Twitch config'); location.href = buildAuthUrl(); };
      const onLogout = async () => { localStorage.removeItem(TOKEN_KEY); localStorage.removeItem(USER_KEY); setToken(''); setUser(null); try { await clientRef.current?.disconnect(); } catch {}; setConnected(false); };
      const onJoin = () => { const c = (channelInput||'').trim().replace(/^#/, ''); if (!c) return; setChannel(c); setChannelInQuery(c); setMessages([]); };
      const canSend = !!token && !!user?.login && connected && !!channel;
      const onSend = async (text) => {
        const t = (text||'').trim(); if (!t) return; if (!canSend) return alert('Login and connect first');
        try { await clientRef.current?.say('#'+channel, t); setMessages(m => [...m, { username: user.display_name||user.login, color:'#cbb4ff', badges:['You'], text: t }]); } catch (e) { console.error(e); }
      };

      return html`
        <${HeaderComp} loggedIn=${!!user} onLogin=${onLogin} onLogout=${onLogout} user=${user} connection=${connected} />
        <main class="container">
          <section class="panel">
            <div class="status">
              <${Dot} on=${connected} />
              <div>${connecting ? 'Connecting…' : (connected ? `Connected to #${channel||''}` : 'Disconnected')}</div>
              <div class="spacer"></div>
              <div class="subtle">${user ? `@${user.login}` : 'Not logged in'}</div>
            </div>
            <div class="controls">
              <div class="identity">
                <div class="avatar">${(user?.display_name||user?.login||'?').slice(0,1).toUpperCase()}</div>
                <div class="userline">
                  <b id="displayName">${user?.display_name||'Guest'}</b>
                  <small id="loginName">${user?('@'+user.login):'@anonymous'}</small>
                </div>
              </div>
              <div class="field">
                <label class="subtle" for="channel">Channel</label>
                <input id="channel" value=${channelInput} onInput=${e=>setChannelInput(e.currentTarget.value)} placeholder="e.g. twitch" />
                <button onClick=${onJoin}>Join</button>
              </div>
              <div class="field">
                <button class="secondary" onClick=${()=>setMessages([])}>Clear</button>
              </div>
            </div>
            <div class="chat">
              <${VirtualList}
                ref=${listRef}
                class="messages"
                style=${{ height: '100%' }}
                data=${messages}
                rowHeight=${24}
                overscanCount=${10}
                renderRow=${row => html`<${MessageRow} ...${row} />`}
              />
              <div class="composer">
                <input
                  value=${compose}
                  onInput=${e=>setCompose(e.currentTarget.value)}
                  onKeyDown=${e=>{ if (e.key==='Enter' && !e.shiftKey) { e.preventDefault(); onSend(compose); setCompose(''); } }}
                  placeholder=${canSend? 'Type a message...' : 'Login with Twitch and join a channel to chat'}
                  disabled=${!canSend}
                />
                <button onClick=${()=>{ onSend(compose); setCompose(''); }} disabled=${!canSend}>Send</button>
              </div>
            </div>
          </section>
        </main>
      `;
    };

    const HeaderComp = ({ loggedIn, onLogin, onLogout, user }) => html`
      <header>
        <div class="brand">
          <div class="logo">TW</div>
          <div>
            <div style="font-size:15px">Twitch Chat Viewer</div>
            <div style="font-size:12px; color:var(--muted)">${loggedIn ? `Logged in as @${user?.login}` : 'Login and watch chat in real time'}</div>
          </div>
        </div>
        <div class="actions">
          ${!loggedIn ? html`<button onClick=${onLogin}>Login with Twitch</button>` : html`<button class="secondary" onClick=${onLogout}>Logout</button>`}
        </div>
      </header>
    `;

    render(html`<${App}/>`, document.getElementById('app'));
  </script>
</body>
</html>